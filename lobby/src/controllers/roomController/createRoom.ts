import { DataFromServer, RoomTimer } from "../../types/types";
import { Room } from "@coderoyale/common";
import api from "../../utils/api";
import { getUser, updateUser } from "../userController";
import { getRoom } from "./getRoom";
import { ROOM_PREFIX, ROOM_TIMER_PREFIX } from "../../utils/constants";
import {
  CreateRoomInput,
  ZodValidationResponse,
  CreateRoomInputSchema,
} from "@coderoyale/common";

export const createRoom = async (
  createRoomInput: CreateRoomInput,
  { socket, redis, currentUserId }: DataFromServer
): Promise<ZodValidationResponse> => {
  // check input from client
  const checkInputResult = CreateRoomInputSchema.safeParse(createRoomInput);
  if (!checkInputResult.success) {
    // need to find a better way to do this...this works for now
    return {
      errors: [
        {
          field: checkInputResult.error.issues[0].path[1].toString(),
          message: checkInputResult.error.issues[0].message,
        },
      ],
    };
  }

  // find user in redis
  let user = await getUser(currentUserId, redis!);
  if (!user) {
    return {
      errors: [
        {
          field: "CreateRoom",
          message: "User who tried to create the room does not exist",
        },
      ],
    };
  }

  // disabled for testing, have to re enable
  if (user.currentRoom) {
    // user already in a room, must leave room to create a new room
    return {
      errors: [
        {
          field: "CreateRoom",
          message: "You are already in a room, leave to create a new room.",
        },
      ],
    };
  }

  // this room id is generated by db
  let roomId = null;
  let response;
  // first create room in db
  try {
    response = await api.createRoom({
      title: createRoomInput.config.title,
      private: createRoomInput.config.private,
      maxMembers: createRoomInput.config.maxMembers,
      creatorId: currentUserId,
    });

    roomId = response.createRoom.id;
  } catch (error) {
    return {
      errors: [
        {
          field: "CreateRoom",
          message: "Failed to create room in DB",
        },
      ],
    };
  }

  const room = await getRoom(roomId, redis!);
  if (room) {
    return {
      errors: [
        {
          field: "CreateRoom",
          message: "There is already a room present by the code given",
        },
      ],
    };
  }

  const newRoom: Room = {
    config: {
      id: roomId,
      private: response.createRoom.private,
      title: response.createRoom.title,
      creatorUsername: response.createRoom.creator.username,
      adminUserId: currentUserId,
      maxTeams: createRoomInput.config.maxTeams,
      maxMembersPerTeam: createRoomInput.config.maxMembersPerTeam,
      maxMembers: createRoomInput.config.maxMembers,
    },
    state: {
      currMemberCount: 1,
      bannedMemberIds: [],
      bench: [currentUserId],
      users: { [currentUserId]: { team: null } },
    },
    competition: {
      questionIds: [],
      maxQuestions: createRoomInput.competition.maxQuestions,
      contestStartedAt: null,
      contestEndedAt: null,
      isOngoing: false,
      timeLimit: createRoomInput.competition.timeLimit,
      veto: {
        questionCount: createRoomInput.veto.questionCount,
        questionIds: [],
        maxVoteAllowed: createRoomInput.veto.maxVoteAllowed,
        isOngoing: false,
        timeLimit: createRoomInput.veto.timeLimit,
        votedUserIds: [],
        yetToVoteUserIds: [],
        votes: {},
      },
    },
    teams: {},
  };

  // initializing veto and competition timers
  const newRoomTimer: RoomTimer = {
    competitionTimer: null,
    vetoTimer: null,
  };

  await redis?.set(ROOM_PREFIX + roomId, JSON.stringify(newRoom));
  // initialize timers
  await redis?.set(ROOM_TIMER_PREFIX + roomId, JSON.stringify(newRoomTimer));

  // update user in cache
  user = {
    ...user,
    currentRoom: roomId,
  };
  await updateUser(user, redis!);

  // created room
  socket.join(roomId!);
  return { room: newRoom };
};
